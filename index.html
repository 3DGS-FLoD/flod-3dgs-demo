<!DOCTYPE html>
<html lang="en">

<!-- Last updated time variable -->
<script>
  const LAST_UPDATED_TIME = "Sep 12, 2025, 02:07 PM KST";
</script>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>FLoD-3DGS Demo</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --primary-color: #6366f1;
      --primary-hover: #4f46e5;
      --secondary-color: #f8fafc;
      --accent-color: #06b6d4;
      --text-primary: #1e293b;
      --text-secondary: #64748b;
      --text-muted: #94a3b8;
      --border-color: #e2e8f0;
      --border-hover: #cbd5e1;
      --background: #ffffff;
      --background-secondary: #f8fafc;
      --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
      --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
      --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
      --radius-sm: 0.375rem;
      --radius-md: 0.5rem;
      --radius-lg: 0.75rem;
    }

    * {
      box-sizing: border-box;
    }

    body {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      margin: 0;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      color: var(--text-primary);
      line-height: 1.6;
    }

    a {
      text-decoration: none;
      color: var(--primary-color);
      transition: color 0.2s ease;
    }

    a:hover {
      color: var(--primary-hover);
    }

    .demo-content {
      display: block;
      margin: 20px;
      max-width: 1200px;
      margin-left: auto;
      margin-right: auto;
    }

    .header-content-container {
      background: var(--background);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-lg);
      max-width: 1200px;
      min-width: 350px;
      margin: auto;
      overflow: hidden;
      border: 1px solid var(--border-color);
    }

    .title {
      display: flex;
      text-align: center;
      padding: 2rem;
      background: linear-gradient(135deg, var(--primary-color) 0%, var(--accent-color) 100%);
      color: white;
      font-size: 2rem;
      font-weight: 700;
      margin: 0;
      letter-spacing: -0.025em;
      position: relative;
      overflow: hidden;
    }

    .title::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grain" width="100" height="100" patternUnits="userSpaceOnUse"><circle cx="25" cy="25" r="1" fill="white" opacity="0.1"/><circle cx="75" cy="75" r="1" fill="white" opacity="0.1"/><circle cx="50" cy="10" r="0.5" fill="white" opacity="0.1"/><circle cx="10" cy="60" r="0.5" fill="white" opacity="0.1"/><circle cx="90" cy="40" r="0.5" fill="white" opacity="0.1"/></pattern></defs><rect width="100" height="100" fill="url(%23grain)"/></svg>');
      opacity: 0.3;
    }

    .title span {
      position: relative;
      z-index: 1;
    }

    .small-title {
      font-family: 'Inter', sans-serif;
      font-size: 1.25rem;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 1rem;
      padding: 0 2rem;
      margin-top: 2rem;
    }

    .content-row {
      padding: 2rem;
      display: flex;
      flex-direction: row;
      flex-wrap: wrap;
      text-align: center;
      gap: 1.5rem;
      justify-content: center;
    }

    .demo-scene-panel {
      margin: 0;
      padding: 1.5rem;
      color: var(--text-primary);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-color);
      background: var(--background);
      width: 280px;
      transition: all 0.3s ease;
      box-shadow: var(--shadow-sm);
      position: relative;
      overflow: hidden;
    }

    .demo-scene-panel::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, var(--primary-color), var(--accent-color));
    }

    .demo-scene-panel.clickable:hover {
      transform: translateY(-4px);
      box-shadow: var(--shadow-lg);
      border-color: var(--primary-color);
      cursor: pointer;
    }

    .demo-scene-panel-image {
      width: 100%;
      border-radius: var(--radius-md);
      margin-bottom: 1rem;
      height: 180px;
      object-fit: cover;
      box-shadow: var(--shadow-sm);
      transition: transform 0.3s ease;
    }

    .demo-scene-panel.clickable:hover .demo-scene-panel-image {
      transform: scale(1.05);
    }

    .demo-scene-button-row {
      display: flex;
      flex-direction: row;
      width: 100%;
      justify-content: center;
      gap: 0.5rem;
      margin-top: 1rem;
    }

    .demo-scene-button {
      border-radius: var(--radius-sm);
      border: 1px solid var(--border-color);
      background: var(--background-secondary);
      color: var(--text-secondary);
      padding: 0.5rem 1rem;
      font-size: 0.875rem;
      font-weight: 500;
      transition: all 0.2s ease;
      cursor: pointer;
    }

    .demo-scene-button:hover {
      color: var(--text-primary);
      border-color: var(--primary-color);
      background: var(--primary-color);
      color: white;
    }


    .button {
      color: var(--primary-color);
      border: 1px solid var(--primary-color);
      background: transparent;
      padding: 0.75rem 1.5rem;
      border-radius: var(--radius-md);
      font-weight: 500;
      transition: all 0.2s ease;
      cursor: pointer;
      box-shadow: var(--shadow-sm);
    }

    .button:hover {
      background: var(--primary-color);
      color: white;
      transform: translateY(-1px);
      box-shadow: var(--shadow-md);
    }

    .text-input {
      border: 1px solid var(--border-color);
      background: var(--background);
      padding: 0.75rem;
      border-radius: var(--radius-md);
      font-size: 0.875rem;
      transition: border-color 0.2s ease;
    }

    .text-input:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px rgb(99 102 241 / 0.1);
    }

    .checkbox-input {
      width: 1.25rem;
      height: 1.25rem;
      padding: 0;
      margin: 0;
      accent-color: var(--primary-color);
    }

    .splat-panel {
      margin: 0;
      padding: 1.5rem;
      color: var(--text-primary);
      font-size: 0.875rem;
      font-family: 'Inter', sans-serif;
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-color);
      background: var(--background);
      width: 350px;
      height: 320px;
      box-shadow: var(--shadow-sm);
      transition: all 0.3s ease;
    }

    .splat-panel:hover {
      box-shadow: var(--shadow-md);
    }

    .loading-icon {
      width: 2rem;
      height: 2rem;
      padding: 0;
      background: var(--primary-color);
      border-radius: 50%;
      --_m: conic-gradient(#0000, #000), linear-gradient(#000 0 0) content-box;
      -webkit-mask: var(--_m);
      mask: var(--_m);
      -webkit-mask-composite: source-out;
      mask-composite: subtract;
      box-sizing: border-box;
      animation: ply-load 1s linear infinite;
    }

    @keyframes ply-load {
      to {
        transform: rotate(1turn);
      }
    }

    .controls-key {
      font-weight: 600;
      padding: 0.25rem 0.5rem;
      border: 1px solid var(--border-color);
      background: var(--background-secondary);
      border-radius: var(--radius-sm);
      font-size: 0.75rem;
      color: var(--text-secondary);
    }

    .controls-key-description {
      text-align: left;
      padding-left: 0.75rem;
      color: var(--text-secondary);
      font-size: 0.875rem;
    }

    .file-ext {
      border: #bababa 1px solid;
      border-radius: 3px;
      background-color: #e6e6e6;
      padding-left: 5px;
      padding-right: 5px;
      padding-top: 3px;
      padding-bottom: 3px;
      margin-left: 3px;
      margin-right: 3px;
    }

    .file-ext-small {
      border: #ababab 1px solid;
      border-radius: 3px;
      background-color: #dfdfdf;
      padding-left: 4px;
      padding-right: 4px;
      padding-bottom: 1px;
      margin-left: 3px;
      margin-right: 3px;
    }

    .valid-value-label {
      color: #94a3b8;
      font-size: 0.75rem;
    }

    /* Responsive design */
    @media (max-width: 768px) {
      .demo-content {
        margin: 10px;
      }
      
      .content-row {
        padding: 1rem;
        gap: 1rem;
      }
      
      .demo-scene-panel {
        width: 100%;
        max-width: 320px;
      }
      
      .title {
        font-size: 1.5rem;
        padding: 1.5rem;
      }
    }

    /* Smooth scrolling */
    html {
      scroll-behavior: smooth;
    }

    /* Focus styles for accessibility */
    button:focus-visible,
    input:focus-visible {
      outline: 2px solid var(--primary-color);
      outline-offset: 2px;
    }

  </style>
  
  <script type="importmap">
    {
        "imports": {
            "three": "./lib/three.module.js",
            "gaussian-splats-3d": "./lib/gaussian-splats-3d.module.js"
        }
    }
  </script>
  <script>
    let currentAlphaRemovalThreshold;
    let currentCameraUpArray;
    let currentCameraPositionArray;
    let currentCameraLookAtArray;
    let currentAntialiased;
    let current2DScene;
    let currentSphericalHarmonicsDegree;
  </script>
  <script type="module">
    import * as GaussianSplats3D from 'gaussian-splats-3d';
    import * as THREE from 'three';

    function fileBufferToSplatBuffer(fileBufferData, format, alphaRemovalThreshold, compressionLevel, sectionSize, sceneCenter, blockSize, bucketSize, outSphericalHarmonicsDegree = 0) {
      if (format === GaussianSplats3D.SceneFormat.Ply) {
        return GaussianSplats3D.PlyLoader.loadFromFileData(fileBufferData.data, alphaRemovalThreshold, compressionLevel, true, outSphericalHarmonicsDegree, sectionSize, sceneCenter, blockSize, bucketSize);
      } else {
        if (format === GaussianSplats3D.SceneFormat.Splat) {
          return GaussianSplats3D.SplatLoader.loadFromFileData(fileBufferData.data, alphaRemovalThreshold, compressionLevel, true, sectionSize, sceneCenter, blockSize, bucketSize);
        } else {
          return GaussianSplats3D.KSplatLoader.loadFromFileData(fileBufferData.data);
        }
      }
    }

    window.onCompressionLevelChange = function(arg) {
      const compressionLevel = parseInt(document.getElementById("compressionLevel").value);
      if (isNaN(compressionLevel) || compressionLevel < 0 || compressionLevel > 2) {
        return;
      }

      for (let i = 1; i <= 3; i++) {
        const element = document.getElementById('advancedCompressionRow' + i);
        if (compressionLevel === 0) {
          element.style.display = 'none';
        } else {
          element.style.display = '';
        }
      }
    }

    window.onFileChange = function(arg, fileNameLabelID) {
      const fileNameLabel = document.getElementById(fileNameLabelID);
      const url = arg.value;
      let lastForwardSlash = url.lastIndexOf('/');
      let lastBackwardSlash = url.lastIndexOf('\\');
      const lastSlash = Math.max(lastForwardSlash, lastBackwardSlash);
      fileNameLabel.innerHTML = url.substring(lastSlash + 1);
    }

    let conversionInProgress = false;
    window.convertPlyFile = function() {
      if (conversionInProgress) return;
      const conversionFile = document.getElementById("conversionFile");
      const compressionLevel = parseInt(document.getElementById("compressionLevel").value);
      const alphaRemovalThreshold = parseInt(document.getElementById("alphaRemovalThreshold").value);
      const sphericalHarmonicsDegree = parseInt(document.getElementById("conversionSphericalHarmonicsDegree").value);
      const sectionSize = 0;
      let sceneCenterArray = document.getElementById("sceneCenter").value;
      const blockSize = parseFloat(document.getElementById("blockSize").value);
      const bucketSize = parseInt(document.getElementById("bucketSize").value);

      sceneCenterArray = sceneCenterArray.split(',');
  
      if (sceneCenterArray.length !== 3) {
        setViewError("Scene center must contain 3 elements.");
        return;
      }

      for (let i = 0; i < 3; i++) {
        sceneCenterArray[i] = parseFloat(sceneCenterArray[i]);

        if (isNaN(sceneCenterArray[i])) {
          setViewError("Invalid scene center.");
          return;
        }
      }
  
      const sceneCenter = new THREE.Vector3().fromArray(sceneCenterArray);

      if (isNaN(compressionLevel) || compressionLevel < 0 || compressionLevel > 2) {
        setConversionError("Invalid compression level.");
        return;
      } else if (isNaN(alphaRemovalThreshold) || alphaRemovalThreshold <0 || alphaRemovalThreshold > 255) {
        setConversionError("Invalid alpha remval threshold.");
        return;
      } else if (isNaN(sphericalHarmonicsDegree) || sphericalHarmonicsDegree < 0 || sphericalHarmonicsDegree > 2) {
        setConversionError("Invalid SH degree.");
        return;
      } else if (isNaN(blockSize) || blockSize < 0.1) {
        setConversionError("Invalid block size.");
        return;
      } else if (isNaN(bucketSize) || bucketSize < 2 || bucketSize > 65536) {
        setConversionError("Invalid bucket size.");
        return;
      } else if (!conversionFile.files[0]) {
        setConversionError("Please choose a file to convert.");
        return;
      }

      setConversionError("");
      const convertButton = document.getElementById("convertButton");

      const conversionDone = (error) => {
        if (error) {
          console.error(error);
          setConversionError("Could not convert file.");
        } else {
          setConversionStatus("Conversion complete!");
          setConversionLoadingIconVisibility(false);
          setConversionCheckIconVisibility(true);
        }
        convertButton.disabled = false;
        conversionInProgress = false;
      }

      try {
        const fileReader = new FileReader();
        fileReader.onload = function(){
          convertButton.disabled = true;
          setConversionStatus("Parsing file...");
          setConversionLoadingIconVisibility(true);
          setConversionCheckIconVisibility(false);
          const conversionFileName = conversionFile.files[0].name.trim();
          const format = GaussianSplats3D.LoaderUtils.sceneFormatFromPath(conversionFileName);
          const fileData = {data: fileReader.result};
          window.setTimeout(() => {
            try {
              const splatBufferPromise = fileBufferToSplatBuffer(fileData, format, alphaRemovalThreshold, compressionLevel,
                                                                 sectionSize, sceneCenter, blockSize, bucketSize, sphericalHarmonicsDegree);
              splatBufferPromise.then((splatBuffer) => {
                GaussianSplats3D.KSplatLoader.downloadFile(splatBuffer, 'converted_file.ksplat');
                conversionDone();
              });
            } catch (e) {
              conversionDone(e);
            }
          }, 100);
        }
        conversionInProgress = true;
        setConversionStatus("Loading file...");
        setConversionLoadingIconVisibility(true);
        fileReader.readAsArrayBuffer(conversionFile.files[0]);
      } catch (e) {
        conversionDone(e);
      }
    }

    function setConversionError(msg) {
      setConversionLoadingIconVisibility(false);
      setConversionCheckIconVisibility(false);
      document.getElementById("conversionStatus").innerHTML = "";
      document.getElementById("conversionError").innerHTML = msg;
    }

    function setConversionStatus(msg) {
      document.getElementById("conversionError").innerHTML = "";
      document.getElementById("conversionStatus").innerHTML = msg;
    }

    function setConversionLoadingIconVisibility(visible) {
      document.getElementById('conversion-loading-icon').style.display = visible ? 'block' : 'none';
    }

    function setConversionCheckIconVisibility(visible) {
      document.getElementById('check-icon').style.display = visible ? 'block' : 'none';
    }

    window.viewSplat = function() {

      const viewFile = document.getElementById("viewFile");
      const alphaRemovalThreshold = parseInt(document.getElementById("alphaRemovalThresholdView").value);

      let cameraUpArray = document.getElementById("cameraUp").value;
      let cameraPositionArray = document.getElementById("cameraPosition").value;
      let cameraLookAtArray = document.getElementById("cameraLookAt").value;
      let antialiased = document.getElementById("antialiased").checked;
      let sceneIs2D = document.getElementById("2dScene").checked;
      let sphericalHarmonicsDegree = parseInt(document.getElementById("viewSphericalHarmonicsDegree").value);

      cameraUpArray = cameraUpArray.split(',');
      cameraPositionArray = cameraPositionArray.split(',');
      cameraLookAtArray = cameraLookAtArray.split(',');

      if (!viewFile.files[0]) {
        setViewError("Please choose a file to view.");
        return;
      } else if (isNaN(alphaRemovalThreshold) || alphaRemovalThreshold < 0 || alphaRemovalThreshold > 255) {
        setViewError("Invalid alpha remval threshold.");
        return;
      } else if (isNaN(sphericalHarmonicsDegree) || sphericalHarmonicsDegree < 0 || sphericalHarmonicsDegree > 2) {
        setViewError("Invalid SH degree.");
        return;
      }

      if (cameraUpArray.length !== 3) {
        setViewError("Camera up must contain 3 elements.");
        return;
      }

      if (cameraPositionArray.length !== 3) {
        setViewError("Camera position must contain 3 elements.");
        return;
      }

      if (cameraLookAtArray.length !== 3) {
        setViewError("Camera look-at must contain 3 elements.");
        return;
      }

      for (let i = 0; i < 3; i++) {
        cameraUpArray[i] = parseFloat(cameraUpArray[i]);
        cameraPositionArray[i] = parseFloat(cameraPositionArray[i]);
        cameraLookAtArray[i] = parseFloat(cameraLookAtArray[i]);

        if (isNaN(cameraUpArray[i])) {
          setViewError("Invalid camera up.");
          return;
        }

        if (isNaN(cameraPositionArray[i])) {
          setViewError("Invalid camera position.");
          return;
        }

        if (isNaN(cameraLookAtArray[i])) {
          setViewError("Invalid camera look-at.");
          return;
        }
      }

      const viewFileName = viewFile.files[0].name.trim();
      const format = GaussianSplats3D.LoaderUtils.sceneFormatFromPath(viewFileName);

      currentAlphaRemovalThreshold = alphaRemovalThreshold;
      currentCameraUpArray = cameraUpArray;
      currentCameraPositionArray = cameraPositionArray;
      currentCameraLookAtArray = cameraLookAtArray;
      currentAntialiased = antialiased;
      current2DScene = sceneIs2D;
      currentSphericalHarmonicsDegree = sphericalHarmonicsDegree;

      try {
        const fileReader = new FileReader();
        fileReader.onload = function(){
          try {
           runViewer(fileReader.result, format, alphaRemovalThreshold, cameraUpArray, cameraPositionArray, cameraLookAtArray, antialiased, sceneIs2D, sphericalHarmonicsDegree);
          } catch (e) {
            console.error(e);
            setViewError("Could not view scene.");
          }
        }
        setViewStatus("Loading scene...");
        fileReader.readAsArrayBuffer(viewFile.files[0]);
      } catch (e) {
        console.error(e);
        setViewError("Could not view scene.");
      }
    }

    function setViewError(msg) {
      setViewLoadingIconVisibility(false);
      document.getElementById("viewStatus").innerHTML = "";
      document.getElementById("viewError").innerHTML = msg;
    }

    function setViewStatus(msg) {
      setViewLoadingIconVisibility(true);
      document.getElementById("viewError").innerHTML = "";
      document.getElementById("viewStatus").innerHTML = msg;
    }

    function setViewLoadingIconVisibility(visible) {
      document.getElementById('view-loading-icon').style.display = visible ? 'block' : 'none';
    }
  
    window.addEventListener("popstate", (event) => {
      if (currentAlphaRemovalThreshold !== undefined) {
        window.location = 'index.html?art=' + currentAlphaRemovalThreshold + '&cu=' + currentCameraUpArray + "&cp=" + currentCameraPositionArray + "&cla=" + currentCameraLookAtArray + "&aa=" + currentAntialiased + "&2d=" + current2DScene + "&sh=" + currentSphericalHarmonicsDegree;
      } else {
        window.location = 'index.html';
      }
    });

    function runViewer(splatBufferData, format, alphaRemovalThreshold, cameraUpArray, cameraPositionArray, cameraLookAtArray, antialiased, sceneIs2D, sphericalHarmonicsDegree) {
      const viewerOptions = {
        'cameraUp': cameraUpArray,
        'initialCameraPosition': cameraPositionArray,
        'initialCameraLookAt': cameraLookAtArray,
        'halfPrecisionCovariancesOnGPU': false,
        'antialiased': antialiased || false,
        'splatRenderMode': sceneIs2D ? GaussianSplats3D.SplatRenderMode.TwoD : GaussianSplats3D.SplatRenderMode.ThreeD,
        'sphericalHarmonicsDegree': sphericalHarmonicsDegree
      };
      const splatBufferOptions = {
        'splatAlphaRemovalThreshold': alphaRemovalThreshold
      };
      const splatBufferPromise = fileBufferToSplatBuffer({data: splatBufferData}, format, alphaRemovalThreshold, 0,
                                                          undefined, undefined, undefined, undefined, sphericalHarmonicsDegree);
      splatBufferPromise.then((splatBuffer) => {
        document.getElementById("demo-content").style.display = 'none';
        document.body.style.backgroundColor = "#000000";
        history.pushState("ViewSplat", null);
        const viewer = new GaussianSplats3D.Viewer(viewerOptions);
        viewer.addSplatBuffers([splatBuffer], [splatBufferOptions])
        .then(() => {
            viewer.start();
        });
      });
    }

  </script>
  <script>
    function openDemo(page, params) {
      let url = page + '.html';
      if (params && params.length > 0) {
        let index = 0;
        for (let param of params) {
          url += (index === 0 ? "?" : "&");
          url += param[0] + "=" + param[1];
          index++;
        }
      }
      window.location = url;
    }
    function reset() {
      window.location = 'index.html';
    }
  </script>
</head>

<body>
  <div class="demo-content">
    <br>
    <div class="header-content-container">
      <div class="title">
        <div style="margin: auto">
          <div>FLoD-3DGS Demo</div>
          <div style="font-size: 0.6em; opacity: 0.8; margin-top: 0.5rem; font-weight: 400;">
            Last updated: <span id="last-updated"></span>
          </div>
        </div>
      </div>
      <div style="padding-left: 20px; padding-right: 20px;">
        Three.js-based implementation of a renderer for <a href="https://3dgs-flod.github.io/flod/">FLoD: Integrating Flexible Level of Detail into 3D Gaussian Splatting for Customizable Rendering</a>. 
        <br>
        The demos load models directly from Hugging Face. Each scene supports multiple levels of detail for optimal performance.
      </div>
      <br>
    </div>
    <br>
    <div class="header-content-container">
        <div class="title">
          <div style="margin: auto; font-size: 14pt;">
            Demo Scenes
          </div>
        </div>
        <div style="text-align:center;">
          <div class="content-row">
            <div class="demo-scene-panel">
              <div class="small-title">Garden</div>
              <img src="docs/assets/images/garden.png" class="demo-scene-panel-image">
              <div class="demo-scene-button-row">
                <div class="demo-scene-button" onclick="openDemo('docs/garden', [['mode', '3']])">Open</div>
              </div>
            </div>
            <div class="demo-scene-panel">
              <div class="small-title">Kitchen</div>
              <img src="docs/assets/images/kitchen.png" class="demo-scene-panel-image">
              <div class="demo-scene-button-row">
                <div class="demo-scene-button" onclick="openDemo('docs/kitchen', [['mode', '3']])">Open</div>
              </div>
            </div>
            <div class="demo-scene-panel">
              <div class="small-title">Stump</div>
              <img src="docs/assets/images/stump.png" class="demo-scene-panel-image">
              <div class="demo-scene-button-row">
                <div class="demo-scene-button" onclick="openDemo('docs/stump', [['mode', '3']])">Open</div>
              </div>
            </div>
          </div>
        </div>
    </div>
    <br>
  </div>
</body>

  <script>

document.body.onload = function () {
    if (window.location.search) {
      const tokens = window.location.search.substring(1).split("&");
      for (token of tokens) {
        const component = token.split("=");
        const varName = component[0];
        if (varName == "art") {
          currentAlphaRemovalThreshold = component[1];
          document.getElementById('alphaRemovalThresholdView').value = currentAlphaRemovalThreshold;
        } else if (varName == "cu") {
          currentCameraUpArray = component[1];
          document.getElementById('cameraUp').value = currentCameraUpArray;
        } else if (varName == "cp") {
          currentCameraPositionArray = component[1];
          document.getElementById('cameraPosition').value = currentCameraPositionArray;
        } else if (varName == "cla") {
          currentCameraLookAtArray = component[1];
          document.getElementById('cameraLookAt').value = currentCameraLookAtArray;
        } else if (varName == "aa") {
          currentAntialiased = component[1] === 'true' ? true : false;
          document.getElementById('antialiased').checked = currentAntialiased;
        } else if (varName == "2d") {
          current2DScene = component[1] === 'true' ? true : false;
          document.getElementById('2dScene').checked = current2DScene;
        }  else if (varName == "sh") {
          currentSphericalHarmonicsDegree = component[1];
          document.getElementById('viewSphericalHarmonicsDegree').value = currentSphericalHarmonicsDegree;
        }
      }
    }
    if (history.state === "ViewSplat") {
      history.go(-1);
    }
  };
  </script>

</html>