<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>FLoD Demo - Treehill (Commented Version)</title>
  
  <!-- Google Fonts for modern typography -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  
  <!-- Utility functions for the viewer -->
  <script type="text/javascript" src="js/util.js"></script>
  
  <!-- Import map for ES6 modules - tells the browser where to find external libraries -->
  <script type="importmap">
    {
        "imports": {
            "three": "./lib/three.module.js",
            "@mkkellogg/gaussian-splats-3d": "./lib/gaussian-splats-3d.module.js"
        }
    }
  </script>
  
  <style>
    /* CSS Custom Properties (variables) for consistent theming */
    :root {
      --primary-color: #6366f1;      /* Main button color - blue */
      --primary-hover: #4f46e5;      /* Button hover state - darker blue */
      --accent-color: #06b6d4;       /* Accent color for borders - cyan */
      --active-color: #10b981;       /* Active/selected state - green */
      --text-primary: #1e293b;       /* Primary text color */
      --text-secondary: #64748b;     /* Secondary text color */
      --background: #000000;         /* Page background - black */
      --overlay-bg: rgba(0, 0, 0, 0.8); /* Overlay background with transparency */
      --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1); /* Drop shadow */
      --radius-md: 0.5rem;           /* Border radius for rounded corners */
    }

    /* Reset all elements to use border-box sizing */
    * {
      box-sizing: border-box;
    }

    /* Main page styling */
    body {
      background: var(--background);
      height: 100vh;                 /* Full viewport height */
      margin: 0;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      overflow: hidden;               /* Prevent scrollbars */
      position: relative;
    }

    /* Right-side controls panel */
    .controls-overlay {
      position: fixed;                /* Fixed position so it stays in place */
      top: 1rem;                      /* Distance from top of screen */
      right: 1rem;                    /* Distance from right of screen */
      background: rgba(0, 0, 0, 0.7); /* Semi-transparent black background */
      color: white;
      padding: 1rem;
      border-radius: var(--radius-md);
      font-size: 0.875rem;
      backdrop-filter: blur(10px);    /* Blur effect behind the panel */
      border: 1px solid rgba(255, 255, 255, 0.1); /* Subtle white border */
      z-index: 100;                   /* Ensure it appears above other content */
    }

    /* Title styling for control sections */
    .controls-title {
      font-weight: 600;
      margin-bottom: 0.75rem;
      color: var(--primary-color);
    }

    /* Individual control item container */
    .control-item {
      display: flex;                  /* Flexbox layout for alignment */
      align-items: center;            /* Center items vertically */
      margin-bottom: 0.5rem;
    }

    /* Styling for keyboard key indicators */
    .control-key {
      background: var(--primary-color);
      color: white;
      padding: 0.25rem 0.5rem;
      border-radius: 0.25rem;
      font-size: 0.75rem;
      font-weight: 600;
      margin-right: 0.75rem;
      min-width: 2rem;                /* Ensure consistent width */
      text-align: center;
    }

    /* Description text for controls */
    .control-description {
      color: rgba(255, 255, 255, 0.9);
    }

    /* Responsive design for mobile devices */
    @media (max-width: 768px) {
      .controls-overlay {
        top: 0.5rem;
        right: 0.5rem;
        left: 0.5rem;                 /* Extend to left edge on mobile */
        font-size: 0.75rem;
      }
    }
  </style>
</head>

<body>
  
  <!-- Right-side controls panel explaining how to use the interface -->
  <div class="controls-overlay">
    <div class="controls-title">Controls</div>
    <div class="control-item">
      <div class="control-key">WASD</div>
      <div class="control-description">Move camera</div>
    </div>
    <div class="control-item">
      <div class="control-key">Mouse</div>
      <div class="control-description">Look around</div>
    </div>
    <div class="control-item">
      <div class="control-key">Scroll</div>
      <div class="control-description">Zoom in/out</div>
    </div>
    <!-- Level control section -->
    <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid rgba(255, 255, 255, 0.2);">
      <div style="font-weight: 600; margin-bottom: 0.5rem; color: var(--primary-color);">Level Controls</div>
      <div class="control-item">
        <div class="control-key">1-5</div>
        <div class="control-description">Keyboard: Toggle level on/off</div>
      </div>
    </div>
  </div>

  <!-- Left-side level selection panel -->
  <div style="position: fixed; top: 1rem; left: 1rem; background: rgba(0, 0, 0, 0.7); color: white; padding: 1rem; border-radius: 0.5rem; font-size: 0.875rem; backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.1); z-index: 100;">
    <div style="font-weight: 600; margin-bottom: 0.5rem; color: var(--primary-color);">Level Selection</div>
    <!-- Level buttons - each has a unique ID for JavaScript manipulation -->
    <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
      <button id="level-btn-1" onclick="loadLevel(1)" style="background: var(--primary-color); color: white; border: none; padding: 0.5rem 1rem; border-radius: 0.25rem; cursor: pointer; font-size: 0.875rem; transition: all 0.2s ease;">Level 1</button>
      <button id="level-btn-2" onclick="loadLevel(2)" style="background: var(--primary-color); color: white; border: none; padding: 0.5rem 1rem; border-radius: 0.25rem; cursor: pointer; font-size: 0.875rem; transition: all 0.2s ease;">Level 2</button>
      <button id="level-btn-3" onclick="loadLevel(3)" style="background: var(--primary-color); color: white; border: none; padding: 0.5rem 1rem; border-radius: 0.25rem; cursor: pointer; font-size: 0.875rem; transition: all 0.2s ease;">Level 3</button>
      <button id="level-btn-4" onclick="loadLevel(4)" style="background: var(--primary-color); color: white; border: none; padding: 0.5rem 1rem; border-radius: 0.25rem; cursor: pointer; font-size: 0.875rem; transition: all 0.2s ease;">Level 4</button>
      <button id="level-btn-5" onclick="loadLevel(5)" style="background: var(--primary-color); color: white; border: none; padding: 0.5rem 1rem; border-radius: 0.25rem; cursor: pointer; font-size: 0.875rem; transition: all 0.2s ease;">Level 5</button>
    </div>
  </div>

  <!-- Main JavaScript code - this is where all the magic happens! -->
  <script type="module">
    // Import the Gaussian Splats 3D library for rendering 3D scenes
    import * as GaussianSplats3D from '@mkkellogg/gaussian-splats-3d';

    // ============================================================================
    // ‚ö†Ô∏è  IMPORTANT: CURRENT SYSTEM STATUS ‚ö†Ô∏è
    // ============================================================================
    //
    // This system is designed to be a multi-level HLOD renderer, but currently has
    // limited functionality:
    //
    // ‚úÖ WHAT WORKS:
    //    - Single level loading/unloading
    //    - HLOD distance calculations (for display only)
    //    - UI state management
    //    - Scene tracking
    //
    // ‚ùå WHAT DOESN'T WORK YET:
    //    - Multiple levels loaded simultaneously
    //    - Distance-based visibility (all levels render at full quality)
    //    - Automatic level switching based on camera distance
    //    - Performance optimization based on distance
    //
    // üîß TO ACHIEVE FULL FUNCTIONALITY, YOU NEED TO IMPLEMENT:
    //    1. Multi-scene loading without replacement
    //    2. Individual splat visibility control
    //    3. Real-time distance-based rendering
    //
    // ============================================================================

    // ============================================================================
    // STEP 1: INITIALIZE THE 3D VIEWER
    // ============================================================================
    
    // Create a new 3D viewer instance with specific camera settings
    const viewer = new GaussianSplats3D.Viewer({
        'cameraUp': [0, -1, -.17],                    // Which direction is "up" in 3D space
        'initialCameraPosition': [-5, -1, -1],         // Starting camera position (x, y, z)
        'initialCameraLookAt': [-1.72477, 0.05395, -0.00147], // What the camera is looking at
        'sphericalHarmonicsDegree': 2                  // Quality of lighting calculations
    });

    // ============================================================================
    // STEP 2: DEFINE THE SCENE CONFIGURATION
    // ============================================================================
    
    // This object defines all available levels and their properties
    // Each level has a path to its data file, a display name, and rendering options
    const scenes = {
        1: {
            path: 'assets/flod_data/treehill/treehill_level1.ksplat',  // File path for this level
            name: 'Treehill Level 1',                                  // Human-readable name
            options: { 
                'progressiveLoad': true,                               // Load gradually for better performance
                'splatAlphaRemovalThreshold': 20                       // Remove very transparent splats
            }
        },
        2: {
            path: 'assets/flod_data/treehill/treehill_level2.ksplat',
            name: 'Treehill Level 2',
            options: { 'progressiveLoad': true, 'splatAlphaRemovalThreshold': 20 }
        },
        3: {
            path: 'assets/flod_data/treehill/treehill_level3.ksplat',
            name: 'Treehill Level 3',
            options: { 'progressiveLoad': true, 'splatAlphaRemovalThreshold': 20 }
        },
        4: {
            path: 'assets/flod_data/treehill/treehill_level4.ksplat',
            name: 'Treehill Level 4',
            options: { 'progressiveLoad': true, 'splatAlphaRemovalThreshold': 20 }
        },
        5: {
            path: 'assets/flod_data/treehill/treehill_level5.ksplat',
            name: 'Treehill Level 5',
            options: { 'progressiveLoad': true, 'splatAlphaRemovalThreshold': 20 }
        }
    };

    // ============================================================================
    // STEP 3: DEFINE STATE VARIABLES
    // ============================================================================
    
    // These variables keep track of the current state of the application
    
    let currentSceneIndex = -1;                    // Index of the currently active scene (-1 means none)
    let isLoading = false;                         // Flag to prevent multiple simultaneous loading operations
    let currentLevel = 0;                          // Which level is currently being viewed
    let selectedLevels = new Set();                // Set of all currently selected levels (can be multiple!)
    let loadedScenes = new Map();                  // Maps level numbers to their scene configuration objects
    let sceneIndices = new Map();                  // Maps level numbers to their scene indices in the viewer

    // ============================================================================
    // STEP 4: DEFINE HLOD PARAMETERS
    // ============================================================================
    
    // These constants control how the Hierarchical Level of Detail (HLOD) system works
    // They come from your reference implementation and control the distance-based rendering
    
    const LOD1_SCALING_LOWER_BOUND = 0.2;         // Minimum scale for level 1 splats
    const SCALING_RATIO = 4;                      // Each level covers 4x the distance of the previous
    const PIXEL_SIZE = 1.0;                       // Size of one pixel in world units

    // ============================================================================
    // STEP 5: IMPLEMENT THE CORE HLOD CALCULATION FUNCTIONS
    // ============================================================================
    
    /**
     * Calculate the maximum distance where a splat of a given scale appears as one pixel
     * This is the core equation from your reference code (Sec 4.4 eq.6)
     * 
     * @param {number} lodScalingLimit - The minimum scale for this LOD level
     * @param {number} fovx - Horizontal field of view in radians
     * @param {number} fovy - Vertical field of view in radians
     * @param {number} width - Width of the viewport in pixels
     * @param {number} height - Height of the viewport in pixels
     * @param {number} pixelSize - Size of one pixel in world units (default: 1.0)
     * @returns {number} The maximum distance where this scale is visible
     */
    function computeProjectionScaleAndDistance(lodScalingLimit, fovx, fovy, width, height, pixelSize = 1.0) {
        // Step 1: Calculate focal lengths from field of view
        // Focal length = width / (2 * tan(fov/2)) - this is the standard camera equation
        const focalLengthX = width / (2.0 * Math.tan(fovx / 2.0));
        const focalLengthY = height / (2.0 * Math.tan(fovy / 2.0));

        // Step 2: Use the smaller focal length to ensure visibility in both dimensions
        // This is conservative - if it's visible in the smaller dimension, it's visible overall
        const focalLength = Math.min(focalLengthX, focalLengthY);
        
        // Step 3: Calculate the distance where the 2D projection equals the pixel size threshold
        // This is the key equation: distance = focal_length * scale / pixel_size
        const maxDistance = focalLength * lodScalingLimit / pixelSize;
        
        return maxDistance;
    }

    /**
     * Calculate the distance ranges for each LOD level based on the scaling parameters
     * This implements the progressive distance band logic from your reference code
     * 
     * @param {number} maxLevel - The highest LOD level to calculate
     * @param {number} minLevel - The lowest LOD level to calculate (default: 1)
     * @returns {Map} Map of level numbers to their distance ranges
     */
    function calculateLODDistanceRanges(maxLevel, minLevel = 1) {
        const distanceRanges = new Map();
        
        // Step 1: Get camera parameters from the viewer
        const camera = viewer.getCamera();
        
        // Convert FOV from degrees to radians and adjust for aspect ratio
        const fovx = camera.fov * (Math.PI / 180) * (camera.aspect || 1); // Horizontal FOV
        const fovy = camera.fov * (Math.PI / 180);                        // Vertical FOV
        
        // Get current viewport dimensions
        const width = window.innerWidth;
        const height = window.innerHeight;
        
        // Log the calculated parameters for debugging
        console.log(`Camera FOV: ${camera.fov}¬∞, FOVx: ${fovx.toFixed(4)}rad, FOVy: ${fovy.toFixed(4)}rad`);
        console.log(`Viewport: ${width}x${height}`);
        
        // Step 2: Calculate distance ranges for each level
        let lodMaxDistUpperBound = 0;  // Start at 0 for the closest level
        
        // Loop from highest level (most detail) to lowest level (least detail)
        for (let lod = maxLevel; lod >= minLevel; lod--) {
            // Calculate the scaling limit for this level
            // Formula: lod_scaling_limit = lod1_scaling_lower_bound / (scaling_ratio ^ (lod - 1 - 1))
            // This creates progressively larger scales for higher LOD levels
            const lodScalingLimit = LOD1_SCALING_LOWER_BOUND / (Math.pow(SCALING_RATIO, lod - 1 - 1));
            
            // Calculate the maximum distance for this level
            const lodMaxDist = computeProjectionScaleAndDistance(lodScalingLimit, fovx, fovy, width, height, PIXEL_SIZE);
            
            // The minimum distance is the maximum distance of the previous (closer) level
            const lodMinDist = lodMaxDistUpperBound;
            lodMaxDistUpperBound = lodMaxDist;  // Update for next iteration
            
            // Store the distance range for this level
            distanceRanges.set(lod, {
                minDistance: lodMinDist,      // Closest distance where this level is visible
                maxDistance: lodMaxDist,      // Farthest distance where this level is visible
                scalingLimit: lodScalingLimit // The scale threshold for this level
            });
            
            console.log(`Level ${lod}: Distance range [${lodMinDist.toFixed(2)}, ${lodMaxDist.toFixed(2)}], Scaling limit: ${lodScalingLimit.toFixed(4)}`);
        }
        
        return distanceRanges;
    }

    // ============================================================================
    // STEP 6: IMPLEMENT SCENE LOADING AND MANAGEMENT
    // ============================================================================
    
    /**
     * Load a scene progressively (NOTE: Currently loads only ONE level at a time)
     * This function loads a single level and replaces any previously loaded level
     * 
     * @param {number} sceneKey - The level number to load (1-5)
     */
    async function loadSceneProgressive(sceneKey) {
        // Prevent multiple simultaneous loading operations
        if (isLoading) {
            console.log('Scene loading already in progress, please wait...');
            return;
        }

        // Get the scene configuration for this level
        const sceneConfig = scenes[sceneKey];
        if (!sceneConfig) {
            console.error(`Scene ${sceneKey} not found`);
            return;
        }

        // Set loading flag and start loading
        isLoading = true;
        console.log(`Loading ${sceneConfig.name}...`);

        try {
            // Step 1: Load the new scene into the viewer
            console.log(`Loading scene: ${sceneConfig.name}`);
            await viewer.addSplatScene(sceneConfig.path, sceneConfig.options);
            
            // Step 2: Track the scene index and configuration
            const newSceneIndex = viewer.getSceneCount() - 1;  // New scenes are added at the end
            sceneIndices.set(sceneKey, newSceneIndex);         // Map level to scene index
            loadedScenes.set(sceneKey, sceneConfig);           // Map level to scene config
            
            console.log(`Scene loaded successfully. Level ${sceneKey} at index ${newSceneIndex}`);
            
            // Step 3: Calculate HLOD distance ranges (for display only - not applied to rendering)
            await applyHLODDistanceRanges();
            
        } catch (error) {
            console.error('Error loading scene:', error);
        } finally {
            isLoading = false;  // Always reset loading flag
        }
    }

    /**
     * Calculate and display HLOD distance ranges - NOTE: These are NOT yet applied to actual rendering
     * This function only shows what the distance ranges would be if HLOD was fully implemented
     * Currently, all selected levels are rendered at full quality regardless of distance
     */
    async function applyHLODDistanceRanges() {
        // Don't do anything if no levels are selected
        if (selectedLevels.size === 0) return;
        
        // Step 1: Find the range of selected levels
        const maxLevel = Math.max(...selectedLevels);  // Highest level number
        const minLevel = Math.min(...selectedLevels);  // Lowest level number
        
        console.log(`Calculating HLOD distance ranges for levels ${minLevel} to ${maxLevel}`);
        
        // Step 2: Calculate distance ranges for the selected levels
        const distanceRanges = calculateLODDistanceRanges(maxLevel, minLevel);
        
        // Step 3: Log the calculated distance ranges for informational purposes
        console.log('HLOD Distance Ranges calculated (for display only):');
        distanceRanges.forEach((range, level) => {
            if (selectedLevels.has(level)) {
                console.log(`Level ${level}: Would be visible from ${range.minDistance.toFixed(2)} to ${range.maxDistance.toFixed(2)} units IF HLOD was implemented`);
            }
        });
        
        // IMPORTANT: Distance-based visibility is NOT yet implemented
        // This would require:
        // 1. Access to individual splat positions in the viewer
        // 2. Ability to apply visibility masks based on distance from camera
        // 3. Real-time updates as the camera moves
        
        console.log('‚ö†Ô∏è  WARNING: Distance-based visibility NOT implemented - all selected levels are fully visible regardless of distance');
    }

    // ============================================================================
    // STEP 7: IMPLEMENT USER INTERFACE FUNCTIONS
    // ============================================================================
    
    /**
     * Update the visual appearance of level buttons based on selection state
     * This function makes the UI reflect which levels are currently selected
     */
    function updateLevelInfo() {
        // Step 1: Update all buttons based on their selection state
        for (let i = 1; i <= 5; i++) {
            const btn = document.getElementById(`level-btn-${i}`);
            if (btn) {
                if (selectedLevels.has(i)) {
                    // Selected level - green background with cyan border
                    btn.style.background = 'var(--active-color)';
                    btn.style.border = '2px solid var(--accent-color)';
                } else {
                    // Not selected - default blue background
                    btn.style.background = 'var(--primary-color)';
                    btn.style.border = 'none';
                }
            }
        }
    }

    /**
     * Handle level button clicks - toggle levels on/off
     * This is the main function that users interact with
     * 
     * @param {number} level - The level number to toggle (1-5)
     */
    function loadLevel(level) {
        console.log(`Button clicked - toggling level ${level}`);
        
        if (selectedLevels.has(level)) {
            // Step 1: Level is already selected, so deselect it
            selectedLevels.delete(level);
            console.log(`Deselected level ${level}`);
            
            // Step 2: Remove the scene if it's loaded
            if (sceneIndices.has(level)) {
                const sceneIndex = sceneIndices.get(level);
                console.log(`Removing level ${level} scene at index ${sceneIndex}`);
                
                try {
                    // Remove the scene from the viewer
                    viewer.removeSplatScene(sceneIndex);
                    
                    // Clean up our tracking data
                    sceneIndices.delete(level);
                    loadedScenes.delete(level);
                    
                    console.log(`Level ${level} scene removed successfully`);
                } catch (error) {
                    console.error(`Error removing level ${level} scene:`, error);
                }
            }
        } else {
            // Step 3: Level is not selected, so select it
            selectedLevels.add(level);
            console.log(`Selected level ${level}`);
            
            // Step 4: Load the scene
            loadSceneProgressive(level);
        }
        
        // Step 5: Update the UI to reflect the new selection state
        updateLevelInfo();
    }

    // Make the loadLevel function globally accessible so HTML buttons can call it
    window.loadLevel = loadLevel;

    /**
     * Handle keyboard input for level selection
     * This allows users to use number keys 1-5 to toggle levels
     * 
     * @param {KeyboardEvent} event - The keyboard event object
     */
    function handleKeyPress(event) {
        const key = event.key;
        
        // Check if it's a number key 1-5
        if (key >= '1' && key <= '5') {
            const sceneNumber = parseInt(key);
            console.log(`Key ${key} pressed - toggling level ${sceneNumber}`);
            
            // Toggle the level selection (same logic as button clicks)
            if (selectedLevels.has(sceneNumber)) {
                selectedLevels.delete(sceneNumber);
                console.log(`Deselected level ${sceneNumber}`);
                
                // Remove the scene if it's loaded
                if (sceneIndices.has(sceneNumber)) {
                    const sceneIndex = sceneIndices.get(sceneNumber);
                    console.log(`Removing level ${sceneNumber} scene at index ${sceneIndex}`);
                    
                    try {
                        viewer.removeSplatScene(sceneIndex);
                        sceneIndices.delete(sceneNumber);
                        loadedScenes.delete(sceneNumber);
                        console.log(`Level ${sceneNumber} scene removed successfully`);
                    } catch (error) {
                        console.error(`Error removing level ${sceneNumber} scene:`, error);
                    }
                }
            } else {
                selectedLevels.add(sceneNumber);
                console.log(`Selected level ${sceneNumber}`);
                loadSceneProgressive(sceneNumber);
            }
            
            // Update the UI
            updateLevelInfo();
        }
    }

    // ============================================================================
    // STEP 8: INITIALIZE THE APPLICATION
    // ============================================================================
    
    // Start the 3D rendering loop
    viewer.start();

    // Add event listener for keyboard input
    document.addEventListener('keydown', handleKeyPress);

    // Initialize the UI to show the default state
    updateLevelInfo();

    // Log startup information
    console.log('HLOD Demo ready! (Single-Level Loading Mode)');
    console.log('Press keys 1-5 to toggle levels on/off');
    console.log('‚ö†Ô∏è  CURRENTLY: Only ONE level loads at a time (not multiple)');
    console.log('Distance ranges are calculated but NOT applied to rendering');
    console.log('Or click the level buttons to toggle levels interactively');
    
    // ============================================================================
    // SUMMARY OF HOW THIS SYSTEM CURRENTLY WORKS:
    // ============================================================================
    //
    // 1. USER INTERACTION:
    //    - User clicks buttons or presses keys 1-5
    //    - Each click toggles a level on/off
    //    - ‚ö†Ô∏è  CURRENTLY: Only ONE level can be loaded at a time (not multiple)
    //
    // 2. SCENE MANAGEMENT:
    //    - ‚ö†Ô∏è  CURRENTLY: Only the last selected level is loaded
    //    - Previous levels are replaced when new ones are selected
    //    - Scene tracking is implemented but not fully utilized
    //
    // 3. HLOD CALCULATIONS:
    //    - ‚úÖ Camera FOV and viewport dimensions are automatically detected
    //    - ‚úÖ Distance ranges are calculated using your mathematical formulas
    //    - ‚úÖ Each level covers a progressively larger distance range
    //    - ‚ö†Ô∏è  BUT: These calculations are for display only - NOT applied to rendering
    //
    // 4. VISUAL FEEDBACK:
    //    - ‚úÖ Selected level buttons turn green with cyan borders
    //    - ‚úÖ Unselected buttons remain blue
    //    - ‚úÖ Console shows detailed distance calculations
    //
    // 5. CURRENT LIMITATIONS:
    //    - ‚ùå Only single-level loading (not multi-level as intended)
    //    - ‚ùå No distance-based visibility (all levels render at full quality)
    //    - ‚ùå No performance optimization based on distance
    //    - ‚ùå No automatic level switching as camera moves
    //
    // ============================================================================
    // KEY CONCEPTS TO UNDERSTAND:
    // ============================================================================
    //
    // - Set: A collection of unique values (no duplicates)
    // - Map: A key-value store (like a dictionary)
    // - async/await: Handles asynchronous operations (like file loading)
    // - Event listeners: Respond to user actions (clicks, key presses)
    // - ES6 modules: Modern JavaScript import/export system
    // - CSS custom properties: Variables for consistent theming
    // - Flexbox: Modern CSS layout system
    // - Z-index: Controls which elements appear on top
    //
    // ============================================================================
    // HOW TO ADAPT THIS FOR OTHER PROJECTS:
    // ============================================================================
    //
    // 1. Change the scenes object to point to your data files
    // 2. Adjust the HLOD parameters (scaling bounds, ratios)
    // 3. Modify the camera settings for your scene
    // 4. Update the UI styling to match your design
    // 5. Add new functionality by creating new functions
    // 6. Use the same patterns: state variables, event handlers, async functions
    //
  </script>
</body>

</html>
